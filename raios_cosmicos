import openmc
import openmc.stats
import numpy as np
import openmc.model
from matplotlib import pyplot as plt
import os
from datetime import datetime


# Criar pasta e mudar para a pasta criada:
def mkdir(nome="teste_sem_nome",data=True,voltar=False):
    if (voltar==True):
        os.chdir("../")
    if (data==True):
        agora = datetime.now()
        nome = agora.strftime(nome+"_%Y%m%d_%H%M%S")
    if not os.path.exists(nome):
        os.makedirs(nome)
    os.chdir(nome)


#Mudar para a pasta
def chdir(nome=None):
    if (nome != None):
        os.chdir(nome)
    else:
        diretorio_atual = os.getcwd()
        diretorios = [diretorio for diretorio in os.listdir(diretorio_atual) if os.path.isdir(os.path.join(diretorio_atual, diretorio))]

        data_mais_recente = 0
        pasta_mais_recente = None

        for diretorio in diretorios:
            data_criacao = os.path.getctime(os.path.join(diretorio_atual, diretorio))
            if data_criacao > data_mais_recente:
                data_mais_recente = data_criacao
                pasta_mais_recente = diretorio

        if pasta_mais_recente:
            os.chdir(os.path.join(diretorio_atual, pasta_mais_recente))
            print("Diretório mais recente encontrado:", pasta_mais_recente)
        else:
            print("Não foi possível encontrar um diretório mais recente.")





# Controle das iterações
UPPER_TARUGO_INICIAL = 5.0
UPPER_TARUGO_FINAL= 5.0
UPPER_TARUGO_INCREMENTO=-0.25

#Lista de resultados
UPPER_TARUGO_lista = []
lista_fluxos = []
lista_std_dev = []

#Cria uma pasta RODA_DATA com todos os resultados dentro
mkdir(nome="Balanca_variavel",data=True,voltar=False)

UPPER_TARUGO = UPPER_TARUGO_INICIAL
while UPPER_TARUGO >= UPPER_TARUGO_FINAL:
    #Cria uma pasta para o resultado, volta para pasta anterior antes de criar nova pasta caso não seja a primeira iteração
    mkdir(nome=f"UPPER_TARUGO={UPPER_TARUGO}",data=False,voltar=(UPPER_TARUGO<UPPER_TARUGO_INICIAL) )



    # ======================
    # Materiais
    # ======================

    # Material 1 - Fonte de Cobalto (Co-60)
    cobalto = openmc.Material(name='Fonte de Cobalto')
    cobalto.add_nuclide('Co59', 1.0)
    cobalto.set_density('g/cm3', 8.9)

    # Material 2 - Aço
    aco = openmc.Material(name='Aço')
    aco.add_element('Fe', 0.98)
    aco.add_element('C', 0.02)
    aco.set_density('g/cm3', 7.85)

    # Material 3 - Detector de Cristal de Iodeto de Cesio
    csi = openmc.Material(name='Detector de CsI')
    csi.add_nuclide('Cs133', 0.5)
    csi.add_nuclide('I127', 0.5)
    csi.set_density('g/cm3', 4.51)

    # Material 4 - Água
    agua = openmc.Material(name='Água')
    agua.add_nuclide('H1', 2.0)
    agua.add_nuclide('O16', 1.0)
    agua.set_density('g/cm3', 1.0)

    # Material 5 - Ar
    ar = openmc.Material(name='Ar')
    ar.add_nuclide('N14', 0.755)
    ar.add_nuclide('O16', 0.231)
    ar.add_nuclide('Ar40', 0.013)
    ar.set_density('g/cm3', 0.001225)

    # Marterial 6 - Carvão
    carvao = openmc.Material(name='Carvao Hulha')
    carvao.set_density('g/cm3', 0.793)  

    carvao.add_element('C', 0.78)
    carvao.add_element('H', 0.05)
    carvao.add_element('O', 0.13)
    carvao.add_element('N', 0.02)
    carvao.add_element('S', 0.02)

    # minério de ferro
    ore = openmc.Material(name='Minério de Ferro')
    ore.set_density('g/cm3', 3.5)  # densidade média com umidade e porosidade

    ore.add_element('Fe', 0.6)
    ore.add_element('O', 0.3)
    ore.add_element('Si', 0.05)
    ore.add_element('Al', 0.04)
    ore.add_element('Mn', 0.01)

    
    # Material - Chumbo
    pb = openmc.Material(name='Chumbo')
    pb.add_nuclide('Pb208', 0.524)
    pb.add_nuclide('Pb207', 0.221)
    pb.add_nuclide('Pb206', 0.241)
    pb.add_nuclide('Pb204', 0.014)

    # Criação do conjunto de materiais
    materials = openmc.Materials([cobalto, aco, csi, agua, ar, carvao, ore, pb])
    #materials.cross_sections = "/home/jefferson/GammaMass/nuclear-data/endfb-viii.0-hdf5/cross_sections.xml"
    materials.export_to_xml()
    #print(materials)

    colors = {
        cobalto: 'red',
        aco: 'black',
        ar: (173, 216, 230),
        csi: 'yellow',
        agua: 'blue',
        carvao: 'grey',
        ore: 'brown',
        pb: (45, 79, 56)
    }




    # ======================
    # Geometria (& intersection, > union,  ~ complement.)
    # ======================
    # Fonte (Co-60)
    Co60_cyl=openmc.YCylinder(x0=0, z0=0, r=0.35) #
    plane_y_min = openmc.YPlane(y0=-30)
    plane_y_max = openmc.YPlane(y0=30)

    fonte_cell = openmc.Cell(name='Fonte Co60')
    fonte_cell.region = -Co60_cyl & +plane_y_min & -plane_y_max
    fonte_cell.fill = cobalto

 #############################################
    # Tarugo variável
    BOTTOM_TARUGO  = UPPER_TARUGO -10
    plane_x_min_tarugo = openmc.XPlane(x0=BOTTOM_TARUGO)
    plane_x_max_tarugo = openmc.XPlane(x0=UPPER_TARUGO)
    plane_y_min_tarugo = openmc.YPlane(y0=-7.905)
    plane_y_max_tarugo = openmc.YPlane(y0=7.905)
    plane_z_min_tarugo = openmc.ZPlane(z0=10.45) #
    plane_z_max_tarugo = openmc.ZPlane(z0=26.26) 



    tarugo_cell = openmc.Cell(name='Tarugo de Aço')
    tarugo_cell.region = +plane_x_min_tarugo & -plane_x_max_tarugo & +plane_y_min_tarugo & -plane_y_max_tarugo & +plane_z_min_tarugo & -plane_z_max_tarugo
    tarugo_cell.fill = carvao
 ###############################################
    # esteira
    esteira_min_z = openmc.ZPlane(z0 = 10.35)
    esteira_max_z = openmc.ZPlane(z0 = 10.45)
    esteira_min_x = openmc.XPlane(x0 = -75)
    esteira_max_x = openmc.XPlane(x0 = 75)
    esteira_min_y = openmc.YPlane(y0 = -25)
    esteira_max_y = openmc.YPlane(y0 = 25)

    esteira_cell = openmc.Cell(name='Esteira')
    esteira_cell.region = -esteira_max_z & +esteira_min_z & -esteira_max_x & +esteira_min_x & -esteira_max_y & +esteira_min_y
    esteira_cell.fill = aco

    # Detector de Cristal de CsI
    plane_z_min = openmc.ZPlane(z0=50.35)
    plane_z_max = openmc.ZPlane(z0=55.35) #
    cristal_x_min = openmc.XPlane(x0 =-2) 
    cristal_x_max = openmc.XPlane(x0 =2)
    cristal_y_min = openmc.YPlane(y0 =-2)
    cristal_y_max = openmc.YPlane(y0 =2)


    NaI_cyl = openmc.YCylinder(x0=0.0, z0=52.35, r=3.8)
    disco_cyl = openmc.YCylinder(x0=0.0, z0=52.35, r=3.8)
    plane_y_min = openmc.YPlane(y0=-2.5)
    plane_y_max = openmc.YPlane(y0=2.5)
    plane_y_disco = openmc.YPlane(y0 = -4.3)
    plane_y_clmp = openmc.YPlane(y0 = 31.6)

    detector_cell = openmc.Cell(name='Detector de CsI')
    detector_cell.region = -NaI_cyl & +plane_y_min & -plane_y_max
    detector_cell.fill = csi

    disco_cell = openmc.Cell(name='Disco do detector')
    disco_cell.region = +plane_y_disco & -plane_y_min & -disco_cyl
    disco_cell.fill = aco

    clamping_cell = openmc.Cell(name='Clamping Region')
    clamping_cell.region = -disco_cyl & +plane_y_max & -plane_y_clmp
    clamping_cell.fill = aco

    # Colimador
    janela_cell = openmc.Cell(name='Janela do colimador')
    plane_y_max_janela = openmc.YPlane(y0 = 3.0)
    plane_y_min_janela = openmc.YPlane(y0 = -3.0)
    plane_z_max_janela = openmc.ZPlane(z0 = 52.35)
    plane_z_min_janela = openmc.ZPlane(z0 = 45.75)
    plane_x_max_janela = openmc.XPlane(x0 = 3.9)
    plane_x_min_janela = openmc.XPlane(x0 = -3.9)
    janela_cell.region = +plane_y_min_janela & -plane_y_max_janela & +plane_z_min_janela & -plane_z_max_janela & +plane_x_min_janela & -plane_x_max_janela
    janela_cell.fill = ar # preencher com ar
    

    colimador_cell = openmc.Cell(name='Colimador de Chumbo')
    raiocol_i = openmc.YCylinder(x0 = 0.0, z0 = 52.35, r = 3.8)
    raiocol_e = openmc.YCylinder(x0 = 0.0, z0 = 52.35, r = 6.6)
    plane_y_max_col = openmc.YPlane(y0 = 7.3)
    plane_y_min_col = openmc.YPlane(y0 = -6.4)
    casca_pb = -raiocol_e & +plane_y_min_col & -plane_y_max_col
    interior_col = janela_cell.region | clamping_cell.region | detector_cell.region | disco_cell.region
    colimador_cell.region = casca_pb & ~interior_col
    colimador_cell.fill = pb
    # pra tirar o colimador, trocar o material para ar!

    # Ar
    plane_y_max_vazio = openmc.YPlane(y0=120, boundary_type='vacuum')
    plane_y_min_vazio = openmc.YPlane(y0=-120, boundary_type='vacuum')
    plane_x_max_vazio = openmc.XPlane(x0=120, boundary_type='vacuum')
    plane_x_min_vazio = openmc.XPlane(x0=-120, boundary_type='vacuum')
    plane_z_max_vazio = openmc.ZPlane(z0=75, boundary_type='vacuum')
    plane_z_min_vazio = openmc.ZPlane(z0=-10, boundary_type='vacuum')

    box = (-plane_y_max_vazio & +plane_y_min_vazio & -plane_x_max_vazio & +plane_x_min_vazio & -plane_z_max_vazio & +plane_z_min_vazio)
    inner = (detector_cell.region | tarugo_cell.region | fonte_cell.region | esteira_cell.region | janela_cell.region | colimador_cell.region | clamping_cell.region | disco_cell.region)
  
    ar_region = ar_region = box & ~inner

    ar_cell = openmc.Cell(name='Ar', fill=ar, region=ar_region)
    


    # Criação do universo
    universe_1 = openmc.Universe(cells=[fonte_cell, tarugo_cell, detector_cell, ar_cell, esteira_cell, colimador_cell, janela_cell, clamping_cell, disco_cell])

    geometry = openmc.Geometry()
    geometry.root_universe = universe_1
    geometry.export_to_xml()



    # ======================
    # Parâmetros de Plotagem
    # ======================
    plot = openmc.Plot()
    plot.filename = 'geometry_plot.png'  
    plot.basis = ('yz') # yz
    plot.width = (105 , 105)
    plot.pixels = (850, 850)
    plot.origin = (0, 0, 35)
    plot.color_by = 'material'
    plot.colors = colors
    plots = openmc.Plots([plot])
    plot.show_edges = True  # Mostrar bordas das células
    plot.show_labels = True  # Mostrar rótulos das células

    plots.export_to_xml()
    openmc.plot_geometry()

    #from IPython.display import Image
    #Image('geometry_plot.png')
    #xdg-open geometry_plot.png


    #secao_transversal = openmc.Plot.from_geometry(geometry)
    #universe_1.plot(width=(50,50), origin=(0,0,0), basis='xy')
    universe_1.plot(width=(50,50), origin=(0,0,0), basis='xz')

    # ======================
    # Fonte
    # ======================

    # Espectro de energia do Cobalto-60
    energy_dist = openmc.stats.Discrete([1.1732e6, 1.3325e6], [0.5, 0.5])
    # Distribuição espacial (raio entre 0 e 0.35 cm, cilindro ao longo do eixo z)
    radius_dist = openmc.stats.Uniform(a=0, b=0.35)
    x_dist = openmc.stats.Uniform(-0.35, 0.35)
    y_dist = openmc.stats.Uniform(-30, 30)
    z_dist = openmc.stats.Uniform(-0.35, 0.35)
    y_space_dist = openmc.stats.CartesianIndependent(x=x_dist, y=y_dist, z=z_dist)

    # Criando a fonte com parâmetros definidos
    source = openmc.IndependentSource(
        space=y_space_dist,
        angle=openmc.stats.Isotropic(),  # Ângulo isotrópico
        energy=energy_dist,              # Espectro de energia para Co-60
        strength=3.7e7,                  # Intensidade da fonte
        particle='photon'
    )

    # distribuição de fonte de raios cósmicos (1 m² 15.65 cm acima do detector)
    x_dist_rc = openmc.stats.Uniform(-50.0, 50.0)
    y_dist_rc = openmc.stats.Uniform(-50.0, 50.0)
    z_dist_rc =  openmc.stats.Uniform(70.0, 70.0)
    space_rc = openmc.stats.CartesianIndependent(x=x_dist_rc, y=y_dist_rc, z=z_dist_rc)
    # espectro de energia de raios cósmicos (falta corrigir de acordo com expacs)
    espectro_rc = openmc.stats.Discrete([1.0e6], [1.0])

    raios_c = openmc.IndependentSource(
        space = space_rc,
        angle = openmc.stats.Monodirectional((0,0,-1)),
        energy = espectro_rc,
        strength = 3.7e9,               # corrigir intensidade da fonte de acordo com expacs
        particle = 'photon'
    )

    filtro_energia_exemplo = openmc.EnergyFilter([1,2])   # descobrir o que isso faz e como usar o pulse height tally
    particle_foton = openmc.ParticleFilter(bins='photon')

    tally_flux = openmc.Tally(name='Fluxo de fótons chegando ao cristal')
    detector_filter = openmc.CellFilter(detector_cell)
    tally_flux.filters.append(particle_foton)
    tally_flux.filters.append(detector_filter)
    tally_flux.scores.append('flux')

    tallies = openmc.Tallies([tally_flux])
    tallies.export_to_xml()







    # ======================
    # Configurações
    # ======================

    settings = openmc.Settings()
    settings.output = {'tallies': False}
    settings.source = source
    settings.batches = 100  # Número de batches para simulação
    settings.particles = 15000
    settings.photon_transport=True
    settings.run_mode='fixed source'
    settings.export_to_xml()





    # ======================
    # Rodando openmc
    # ======================
    openmc.run()

    # ======================
    # statepoints
    # ======================


    sp = openmc.StatePoint(f"statepoint.{settings.batches}.h5")
    
    flux = sp.get_tally(scores=['flux'], name='Fluxo de fótons chegando ao cristal')
    flux_mean = flux.mean[0][0][0]
    flux_std_dev = flux.std_dev[0][0][0]
    
    UPPER_TARUGO_lista.append(UPPER_TARUGO)
    lista_fluxos.append(flux_mean)
    lista_std_dev.append(flux_std_dev)
    print(f'Fluxo: {flux_mean:.3e} ± {flux_std_dev:.3e}')


    #Fim do while tem que incrementar:
    UPPER_TARUGO += UPPER_TARUGO_INCREMENTO




print("\nResultados finais:")
for i, (flux, std) in enumerate(zip(lista_fluxos, lista_std_dev)):
    print(f"Iteração {i+1}: {flux:.3e} ± {std:.3e}")


print('Fluxos: ', lista_fluxos)
    # ======================
    # MatPlotLib
    # ======================


plt.style.use("seaborn-v0_8-paper")

# gráfico fluxo por altura do tarugo
plt.plot(UPPER_TARUGO_lista, lista_fluxos, marker='o', color='xkcd:dark pink', linestyle='-', linewidth=1)
plt.xlabel('Distância do Tarugo (cm)',fontsize=20)
plt.ylabel('Fluxo de Fótons no Cristal (cm²/s)', fontsize=20)
plt.title('Fluxo de Fótons no Cristal vs Distância do Tarugo', fontsize=24)

#Gridlines
plt.grid(True, which='both', axis='y', linestyle='--', linewidth=0.2, color='gray')
plt.grid(True, which='both', axis='x', linestyle='--', linewidth=0.2, color='gray')
plt.tick_params(axis='both', which='major', labelsize=16)

#plt.axhline(y=lista_std_dev, color='r', linestyle='--', label='Desvio Padrão Médio')
plt.legend(fontsize=22)

plt.tight_layout()
#plt.show()
    
